<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ux on Bison Design</title>
    <link>http://bisondesign.net/tags/ux/index.xml</link>
    <description>Recent content in Ux on Bison Design</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="http://bisondesign.net/tags/ux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Metric for Simplicity</title>
      <link>http://bisondesign.net/post/metric-for-simplicity/</link>
      <pubDate>Thu, 01 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://bisondesign.net/post/metric-for-simplicity/</guid>
      <description>

&lt;h3 id=&#34;the-value-of-simplicity&#34;&gt;The value of simplicity&lt;/h3&gt;

&lt;p&gt;The most complex requirement in software development is simplicity. In this post I
will describe a technique for measuring the simplicity of a UI design. This can be
used to choose the simplest design from a selection.&lt;/p&gt;

&lt;p&gt;I recently ran a training exercise in problem solving with an audience of 50
top developers at a large corporation. Technology companies need to
innovate in order to stay ahead of the competition but innovation requires
problem solving.  But before we can solve problems we need to find them. For
example, I never knew that I absolutely &lt;em&gt;had&lt;/em&gt; to have a fingerprint reader on my
phone until my wife got one. Whoever discovered that we all need a fingerprint
reader was a genius.&lt;/p&gt;

&lt;p&gt;The true genious of this invention is that it is so simple; even a
toddler can learn to unlock a phone if the parents are crazy enough to
register his fingerprints on it. Simplification (represented by the meme &amp;ldquo;Less
if More&amp;rdquo;) is part of solution refinement, the often skipped last step in problem
solving.&lt;/p&gt;

&lt;h3 id=&#34;the-meaning-of-simplicity&#34;&gt;The meaning of simplicity&lt;/h3&gt;

&lt;p&gt;Simplicity has different manifestations in different domains. In mathematics it
is often referred to as elegance. An elegant solution is clear, concise, and
surprising. My favorite example is Cantor&amp;rsquo;s demonstration that the real numbers
are uncoutably infinite. Here he explains it to David Hilbert:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bisondesign.net/images/Diagonal-Proof.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;If Cantor&amp;rsquo;s proof had been clunky, the result would have been just as
beneficial to mathematicians. A clunky proof woudn&amp;rsquo;t really matter as long as
it was still correct. Still, elegant proofs are a delight to behold, even on
repeated viewing.&lt;/p&gt;

&lt;p&gt;Simplicity in software matters. Your product (whether it&amp;rsquo;s an app or a service)
is not an end in itself but a means to an end. In the UI complexity impedes the
end user from doing his task. In code complexity impedes maintainability. In
software design complexity impedes flexibility. A clunky UI, a clunky design
and a clunky implementation do matter.&lt;/p&gt;

&lt;p&gt;Simplicity in software design which closely resembles elegance in mathematics,
is the subject of a future blog post. Here we will stick with the user
experience and in particular simplicity in the UI.&lt;/p&gt;

&lt;h3 id=&#34;a-model-for-the-interaction-of-a-human-with-the-ui&#34;&gt;A model for the interaction of a human with the UI&lt;/h3&gt;

&lt;p&gt;A milestone in the field of usability in computer systems was the publication
of &amp;ldquo;The Psychology of Human-Computer Interaction&amp;rdquo; by Card, Moran, and Newell
(1983). The authors proposed a model of the &amp;ldquo;Human processor&amp;rdquo; citing ten
scientific principles of operation, like &lt;a href=&#34;https://en.wikipedia.org/wiki/Fitts&#39;s_law&#34; title=&#34;Fitts&#39;s law - Wikipedia&#34;&gt;Fitts&amp;rsquo;s law&lt;/a&gt; and the &lt;a href=&#34;https://en.wikipedia.org/wiki/Power_law_of_practice&#34; title=&#34;Power Law of Practice - Wikipedia&#34;&gt;Power Law
of Practice&lt;/a&gt; based on empirical data.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://bisondesign.net/images/03-HumanProcessor_Card_Moran_Newell_1983.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Models are useful for analysis. The suitability of a model can be judged by its
predictive accuracy. Our model of human-computer interaction will be simpler
than the image above which comes from the book, but it will use some of the same
ideas.&lt;/p&gt;

&lt;p&gt;Suppose automated analysis could be added to a UI design tool such as
&lt;a href=&#34;https://balsamiq.com/&#34;&gt;Balamiq Mockups&lt;/a&gt; to help assess the usability of a UI for performing
a specific task at the design stage. Given a task, the UI designer would click,
type and drag to complete the actions needed to complete the task using the
mock, imitating the future user. These would be recorded and analyzed.&lt;/p&gt;

&lt;p&gt;A UI can be designed to accomplish multiple tasks. For example, the same UI may
be used to create an account or change a password: two distinct tasks. In that
case both tasks would be considered in the analysis of the UI. These would not
be given equal weight however. The weight of a task to a given persona will be
proportional to its frequency. For example the number of times that task needs
to be accomplished in a typical year, month or week.&lt;/p&gt;

&lt;p&gt;Being able to accomplish a task is not enough. That&amp;rsquo;s basic suitability
testing. Each interaction with and transition between UI components has a cost.
Clicking on an item that is a big target costs less than if it were small. The
distance the pointer has to move has a cost. Picking an item in a cluttered
menu has a higher cost than clean ones. The sum of the costs is &amp;ldquo;inefficiency&amp;rdquo;.
Our goal will be to minimize inefficiency over the task.&lt;/p&gt;

&lt;p&gt;Simplicity can be measured by the amount of &amp;ldquo;ink&amp;rdquo; or &amp;ldquo;clutter&amp;rdquo; in the UI. Less
is more! In a good UI the quotient of task value, divided by simplicity and
efficiency is the metric by which I will judge the UI.&lt;/p&gt;

&lt;p&gt;The sequence is not necessarily unique.  Sometimes the sequence is constrained,
as when a button is disabled until certain fields are filled in properly.  These
variation can be measured as well.&lt;/p&gt;

&lt;p&gt;This has gotten long enough.  In a future blog post I will discuss:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the model of human behavior while interacting with a UI&lt;/li&gt;
&lt;li&gt;measuring the cost of learning a UI by repeated performance of the same tasks&lt;/li&gt;
&lt;li&gt;metric limitations, given different users have different experience levels&lt;/li&gt;
&lt;li&gt;use of deep learning to refine the model&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;[1] Card, Stuart K.; Moran, Thomas P.; Newell, Allen (1983). The Psychology of
Human–Computer Interaction. Hillsdale, NJ: L. Erlbaum Associates. ISBN
0898592437.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fast Username Validation</title>
      <link>http://bisondesign.net/post/fast-username-validation/</link>
      <pubDate>Tue, 07 Feb 2017 20:21:11 -0500</pubDate>
      
      <guid>http://bisondesign.net/post/fast-username-validation/</guid>
      <description>

&lt;h3 id=&#34;a-good-problem-to-have&#34;&gt;A Good Problem to Have&lt;/h3&gt;

&lt;p&gt;This post describes a novel way to use probabilistic data structures to improve
the user experience of creating a new account.&lt;/p&gt;

&lt;p&gt;You run a site where customers create an account with a user name and password.
Your site is wildly successful and more customers flock to join. Soon all
the good user names are taken. With all your success the fundamental user
experience of creating an account begins to suck.&lt;/p&gt;

&lt;p&gt;Why? The first group of users naturally choose their first name. But there are
4.8 million &lt;em&gt;James&lt;/em&gt; in the United States and almost as many &lt;em&gt;Johns&lt;/em&gt;. The
&lt;a href=&#34;http://names.mongabay.com/male_names.htm&#34;&gt;twenty most common male names&lt;/a&gt;
account for 32 percent of the male population. There are about 4 million
&lt;em&gt;Marys&lt;/em&gt; and 1.6 million &lt;em&gt;Patricias&lt;/em&gt;. Incredibly prospective customers are told,
&lt;em&gt;&amp;ldquo;Sorry, username &amp;lsquo;Maurice&amp;rsquo; is already taken&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;First initial and last name will go a lot further. However, thanks to human
psychology, we again run out of steam sooner than you expect. At my company,
there were three John Lloyds. Some first names just sound better with a
lastname like John and Lloyd. As a parent of five I can attest to thinking a
lot about that.&lt;/p&gt;

&lt;!-- img src=&#34;https://imgs.xkcd.com/comics/baby_names.png&#34;/ --&gt;

&lt;h3 id=&#34;username-validation-requirements&#34;&gt;Username validation requirements&lt;/h3&gt;

&lt;p&gt;By the time you reach 50,000 users (congratulations, by the way) your sucky UI
will require the user to make repeated attempts to find a name that is not
taken. Some frustrated non-customers are giving up; now you need to fix this
problem quickly. For the ideal user experience your account creation UI needs
to be simple and responsive.  It should have these properties:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A visual queue that the name being typed is not yet taken&lt;/li&gt;
&lt;li&gt;Less than 0.5s latency when checking if a given name is taken&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The visual queue could be a greyed out &amp;ldquo;Submit&amp;rdquo; button whenever the name is
already taken. It could also be a pink background in the user name text input
box. With these improvements, your customers will once again be able to choose
a name easily without the heartbreak of repeated rejections. The low latency
is needed for the impression of a responive UI.&lt;/p&gt;

&lt;table&gt;
   &lt;tr&gt;
      &lt;td&gt;&lt;img src=&#34;http://bisondesign.net/images/NewAccountDialogEmpty.png&#34;/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img src=&#34;http://bisondesign.net/images/NewAccountMissingPassword.png&#34;/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img src=&#34;http://bisondesign.net/images/NewAccountReadyToSubmit.png&#34;/&gt;&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The three images above show how a simple dialog can provide feedback for a
taken username, a weak password, and a non-matching confirmation. In all
cases the background is pink when there is a problem.  The submit button
is enabled only once all three problems are eliminated.  Doing all three
checks on the client side leads to a repsonsive and simple user experience.&lt;/p&gt;

&lt;h3 id=&#34;probabilistic-data-structures&#34;&gt;Probabilistic data structures&lt;/h3&gt;

&lt;p&gt;This type of behavior should be done in JavaScript on the browser.
Unfortunately, you can&amp;rsquo;t just download a long list of taken names. Even a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Trie&#34;&gt;trie&lt;/a&gt; of names is too big. A trie can
compress common prefixes but the number of nodes is still proportional to the
number of distinct names in the trie. The sheer number of names appears to make
a client side solution impossible. Unless of course you are willing to trade
off certainty for size.&lt;/p&gt;

&lt;p&gt;Enter a probabilistic data structure called a &lt;a href=&#34;https://en.wikipedia.org/wiki/Bloom_filter&#34;&gt;Bloom
Filter&lt;/a&gt;. Probabilistic algorithms
behave like normal algorithms but have a theoretical chance of being wrong. The
trade off is that they act faster or require less memory to produce the result.&lt;/p&gt;

&lt;p&gt;A Bloom Filter is a probabilistic (unreliable) set. Unlike a trie, a Bloom
Filter can compress both the letters and the number of words in a collection to
an in-memory bit vector. You can&amp;rsquo;t always trust that a true result from testing
set membership is correct, but a simple formula gives staticstical limits on
the number of false positives. Here is how it works.&lt;/p&gt;

&lt;p&gt;Suppose the bit vector has size M, where M is very large. To add user name S to
the filter, compute k hash values ${h_0(S), h_1(S), &amp;hellip;, h_k(S)}$ and set
those bits to 1. The k hash functions should be &lt;em&gt;independent&lt;/em&gt;. The numbers M
and k are selected based on the expected number of names. Checking for the presence
of a name involves calculating the same set of bits and testing it they are set.
If even one of them is not set, then the name could not be present in the fitler.
If, however, they are all set, the name is only likely to be present.&lt;/p&gt;

&lt;p&gt;The space advantage in a Bloom Filter comes from the compactness from the data
structure. A Bloom filter with 1% error and an optimal value of k, requires
only about 9.6 bits (1.2 bytes) per element — regardless of the size of the
elements.  So a site with 50,000 user names would require 64K bytes for a filter.
That&amp;rsquo;s the size of a small (400x600) gif image.&lt;/p&gt;

&lt;p&gt;A word of caution. The theoretical percent error assumes the hash functions are
mutually independent.  It is not that easy to get a family of independent hash
functions, but based on my research the error is not too far off.&lt;/p&gt;

&lt;h3 id=&#34;edge-cases-and-recommendations&#34;&gt;Edge cases and Recommendations&lt;/h3&gt;

&lt;p&gt;There is a delay between the time that the bloom filter is calculated on the
server and when it is used on the client.  Suppose for the sake of argument that
your site has 50,000 names and adds 600 more users every day.  The bloom filter
may be recalculated 6 times a day and republished.&lt;/p&gt;

&lt;p&gt;If a new user happens to pick one if these 100 new user names before they are
added they &lt;em&gt;might&lt;/em&gt; still get a false negative.&lt;/p&gt;

&lt;p&gt;What do you do when a false negative happens? The simplest solution is to blame
latency. The user does not know that we are calculating taken names locally
using a Bloom Filter. The UI could optimistically send the names being typed
(after a 0.5 second pause) on to the server to validate.  If the latency to
your server is small, the additional check will only take an extra second.  If
the name is indeed still not taken, the &amp;ldquo;Submit&amp;rdquo; button can be enabled.  If
it happended to be among the 100 newly added names, that fact is sent to the
client which adds the name to a stoplist of known taken names.  The stoplist
can be uploaded along with the Bloom Filter.&lt;/p&gt;

&lt;p&gt;As you start out your web site all you really need is a stoplist to get the
same user experience. One thousand 20 letter user names is only 20K
un-compressed. Design your UX to scale up to 50 or 100 times as many users and
change the test to use a bloom filter when the download size of the stoplist
get&amp;rsquo;s too big.&lt;/p&gt;

&lt;h3 id=&#34;limitations-and-conclusion&#34;&gt;Limitations and Conclusion&lt;/h3&gt;

&lt;p&gt;Facebook has over 1.8 billion active users. A Bloom Filter solution will not
scale to Facebook proportions. Google has the same &amp;lsquo;problem&amp;rsquo;. In these cases
validation happens on the server and the server suggests a number of untaken
names to the user following certain patterns. Can you think of a way in which
the giant could improve on this?&lt;/p&gt;

&lt;p&gt;Good luck and I hope you enjoyed my first technical blog post. In the future
I will share some code for making fast username validation happen.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>